# 数字电子技术理论笔记

{{< admonition type=warning title="" open=false >}}
此笔记由我个人整理，因此相比教材可能有出入，如果您发现有错误，欢迎和我联系！
{{< /admonition >}}
{{< admonition type=note title="" open=false >}}
此笔记针对西南交通大学2022-2023学年上半学期开设的数电理论课。
{{< /admonition >}}

> # 1 数字逻辑概论

> ## 1.1 数字信号和数字电路

> ### 1.1.1 模拟信号和数字信号

> #### 1.1.1.1 模拟信号

模拟信号是时间和数值均连续变化的电信号，如正弦波、三角波等

> #### 1.1.1.2 数字信号

数字信号是在时间上和数值上均是离散的信号。

> #### 1.1.1.3 模拟信号转换为数字信号

处理过程包括：采样、量化、编码。

> ### 1.1.2 数字信号的描述方法

周期 (T) ---- 表示两个相邻脉冲之间的时间间隔

脉冲宽度 ($t_{w}$)---- 脉冲幅值的50%的两个时间所跨越的时间

占空比 Q ----- 表示脉冲宽度占整个周期的百分比

上升时间$t_{r}$ 和下降时间$t_{f}$ ----从脉冲幅值的10%到90% 上升

> ## 1.2 数制

> ### 1.2.1 二进制数和十进制数转换

> #### 1.2.1.1 辗转相除法

将十进制数连续不断地除以2 , 直至商为零，所得余数由低位到高位排列，即为所求二进制数。

> #### 1.2.1.2 从高到低比较大小

![eg2](/images/Mathematical_Electronic/eg2.jpg)


> #### 1.2.1.3 小数的转换

对于二进制的小数部分可写成
$$N_{D} = b_{-1} \times 2^{-1} + b_{-2} \times 2^{-2} + \cdots + b_{-(n-1)} \times 2^{-(n-1)} + b_{-n} \times 2^{-n} \tag{1} $$

将上式两边分别乘以2，得

$$2 \times N_{D} = b_{-1} \times 2^{0} + b_{-2} \times 2^{-1} + \cdots + b_{-(n-1)} \times 2^{-(n-2)} + b_{-n} \times 2^{-(n-1)} \tag{2} $$

由此可见，将十进制小数乘以2，所得乘积的整数即为 $b_1$,不难推知，将十进制小数每次减掉上次所得积中的整数再乘以2，直到满足误差要求进行“四舍五入"为止，就可完成由十进制小数转换成二进制小数。

![eg1](/images/Mathematical_Electronic/eg1.jpg)

{{< admonition type=info title="" open=false >}}
对于八进制和十六进制小数，转换时，由小数点开始，整数部分自右向左，小数部分自左向右，三/四位一组，不够三/四位的添零补齐，则每三/四位二进制数表示一位八/十六进制数
{{< /admonition >}}

> ## 1.3 算数运算

> ### 1.3.1 原码、反码、补码

> #### 1.3.1.1 原码

原码表示办法：正数符号位是0，负数符号位是1，数值用其绝对值的二进制数表示。例如
$$ +5 = \boxed{0}101 \tag{1}$$
$$ -5 = \boxed{1}101 \tag{2}$$

> #### 1.3.1.2 反码

反码又称为“1的补码”，正数的反码与正码相同。求二进制负数的反码的简单办法是，符号位不变，将原码的数值逐位求反得到。

> #### 1.3.1.3 补码

补码即为反码的最低位加1所得的数

> ## 1.4 二进制代码

编码:以一定的规则编制代码来区分和表示不同的数值、字母、符号等信息的过程。

二进制代码的位数(n),与需要编码的事件（或信息）的个数(N)之间应满足以下关系： $$2^{n-1}≤N≤2^{n}$$

> ### 1.4.1 BCD码

从4 位二进制数16种代码中,选择10种来表示0~9个数码的方案有很多种。每种方案产生一种BCD码。

|BCD码十进制数码| 8421码| 2421 码| 5421 码| 余3码| 余3循环码|格雷码|
|- |-----|-----|-----|-----|-----|---------------------------------|
|0 | 0000| 0000| 0000| 0011| 0010|0000|
|1 | 0001| 0001| 0001| 0100| 0110|0001|
|2 | 0010| 0010| 0010| 0101| 0111|0011|
|3 | 0011| 0011| 0011| 0110| 0101|0010|
|4 | 0100| 0100| 0100| 0111| 0100|0110|
|5 | 0101| 1011| 1000| 1000| 1100|0111|
|6 | 0110| 1100| 1001| 1001| 1101|0101|
|7 | 0111| 1101| 1010| 1010| 1111|0100|
|8 | 1000| 1110| 1011| 1011| 1110|1100|
|9 | 1001| 1111| 1100| 1100| 1010|1101|
|10| \   | \   | \   | \   | \   |1111|
|11| \   | \   | \   | \   | \   |1110|
|12| \   | \   | \   | \   | \   |1010|
|13| \   | \   | \   | \   | \   |1011|
|14| \   | \   | \   | \   | \   |1001|
|15| \   | \   | \   | \   | \   |1000|

> #### 1.4.1.1 各编码特点

- 有权码：编码的每一位有固定的权值

- 无权码：编码没有固定的权值

    - 余3码的特点:当两个十进制的和是10时，相应的二进制和正
    好是16，于是可自动产生进位信号,而不需修正.1和9, 2和8,…..6和
    4的余3码。便于求10的补码。（本质上一个数的余3码就是这个数加上3的8421码）
    - 格雷码：任何两个相邻代码之间仅有一位不同。
    - 余3码循环码：相邻的两个代码之间仅一位的状态不同。按余3
    码循环码组成计数器时，每次转换过程只有一个触发器翻转，译
    码时不会发生竞争－冒险现象。（本质上一个数的余3循环码就是这个数加上3的格雷码）

> #### 1.4.1.2 用BCD码表示十进制数
对于一个多位的十进制数，需要有与十进制位数相同的几组BCD代码来表示。例如：

![eg3](/images/Mathematical_Electronic/eg3.jpg)

> #### 1.4.1.3 二进制码与格雷码的转换
1. 二进制码$\rightarrow$格雷码
    - 格雷码的最高位（最左边）与二进制码的最高位相同。
    - 从左到右，逐一将二进制码相邻的两位相加（舍去进位），作为格雷码的下一位。

        ![eg4](/images/Mathematical_Electronic/eg4.jpg)

2. 格雷码$\rightarrow$二进制码
    - 二进制码的最高位（最左边）与格雷码的最高位相同。
    - 将产生的每一位二进制码，与下一位相邻的格雷码相加（舍去进位），作为二进制码的下一位。

        ![eg5](/images/Mathematical_Electronic/eg5.jpg)

> ## 1.5 二值逻辑变量与基本逻辑运算

逻辑运算的描述方式:逻辑代数表达式、真值表、逻辑图、卡诺图、波形图和硬件描述语言（HDL) 等。

> ### 1.5.1 各逻辑门

![ld1](/images/Mathematical_Electronic/logicdoor1.webp)
![ld2](/images/Mathematical_Electronic/logicdoor2.webp)
![ld3](/images/Mathematical_Electronic/logicdoor3.webp)

> ## 1.6 逻辑函数

描述输入变量和输出变量之间的因果关系称为逻辑函数

> ### 1.6.1 表示办法

> #### 1.6.1.1 真值表

> #### 1.6.1.2 表达式
逻辑表达式是用与、或、非等运算组合起来，表示逻辑函数与逻辑变量之间关系的逻辑代数式。
1. 只写使输出变量为1的项
2. 每项之中，变量之间是与的关系
3. 变量为1的用原变量，变量为0的用反变量
4. 项与项之间是或的关系

> #### 1.6.1.3 逻辑图
用与、或、非等逻辑符号表示逻辑函数中各变量之间的逻辑关系所得到的图形称为逻辑图

思路：将逻辑函数式中所有的与、或、非运算符号用相应的逻辑符号代替，并按照逻辑运算的先后次序将这些逻辑符号连接起来，就得到图电路所对应的逻辑图

![eg6](/images/Mathematical_Electronic/eg6.jpg)

> #### 1.6.1.4 波形图

用输入端在不同逻辑信号作用下所对应的输出信号的波形图，表示电路的逻辑关系

![eg7](/images/Mathematical_Electronic/eg7.jpg)

> ### 1.6.2 转换

> #### 1.6.2.1 真值表$\rightarrow$逻辑图

1. 根据真值表写出逻辑表达式
2. 化简逻辑表达式
3. 根据表达式画出逻辑图


> #### 1.6.2.1 逻辑图$\rightarrow$真值表

1. 根据逻辑图逐级写出表达式
2. 化简变换求最简与或式
3. 将输入变量的所有取值逐一代入表达式得真值表

> # 2 逻辑代数与硬件描述语言

> ## 2.1 逻辑代数的基本定理和恒等式

> ### 2.1.1 逻辑代数的基本定律和恒等式

![rules](/images/Mathematical_Electronic/logic_algebra_rules.jpg)

> ### 2.1.2 逻辑代数的基本规则

> #### 2.1.2.1 对偶规则
对于任何逻辑函数式，若将其中的与（•）换成或（+），或（+）换成与（•）；并将1换成0，0换成1；那么，所得的新的函数式就是L的对偶式，记作$L'$。

![eg8](/images/Mathematical_Electronic/eg8.jpg)

当某个逻辑恒等式成立时，则该恒等式两侧的对偶式也相等。这就是对偶规则。利用对偶规则，可从已知公式中得到更多的运算公式.

> #### 2.1.2.2 反演规则
对于任意一个逻辑表达式L，若将其中所有的与（• ）换成或（+），或（+）换成与（•）；原变量换为反变量，反变量换为原变量；将1换成0，0换成1；则得到的结果就是原函数的反函数。

> ## 2.2 逻辑函数表达式的形式

> ### 2.2.1 基本形式

> #### 2.2.1.1 与-或表达式
若干与项进行或逻辑运算构成的表达式。由与运算符和或运算符连接起来。如：
$$ L = A \cdot C + \bar{C} \cdot D $$

> #### 2.2.1.2 或-与表达式
若干或项进行与逻辑运算构成的表达式。由或运算符和与运算符连接起来。如：
$$ L = ( A + C ) \cdot ( B + \bar{C} ) \cdot D $$

> #### 2.2.1.3 其他表达式

> ### 2.2.2 最小项与最小项表达式

> #### 2.2.2.1 最小项的定义

n个变量$X_{1}, X_{2}, …, X_{n}$的最小项是n个因子的乘积，乘积中包含了全部n个变量，每个变量都以它的原变量或非变量的形式在乘积项中出现，且仅出现一次。一般n个变量的最小项应有$2^{n}$个

> #### 2.2.2.2 最小项的性质

- 对于任意一个最小项，只有一组变量取值使得它的值为1
- 任意两个最小项的乘积为0
- 全体最小项之和为1
- 使最小项为1的一组二进制数所对应的十进制数即为最小项的编号值。

> #### 2.2.2.3 最小项的表示

通常用$m_i$表示最小项，m 表示最小项,下标i为最小项编号。

> ### 2.2.3 最大项与最大项表达式

> #### 2.2.3.1 最大项的定义

n个变量$X_1, X_2, …, X_n$的最大项是n个因子或项，每个变量都以它的原变量或非变量的形式在或项中出现，且仅出现一次。一般n个变量的最大项应有$2^n$个

> #### 2.2.3.2 最大项的性质

- 对于任意一个最大项，只有一组变量取值使得它的值为0
- 任意两个最大项的之和为1
- 全体最大项之积为0

> #### 2.2.3.3 最大项的表示

通常用$M_i$表示最大项，M 表示最大项,下标i为最大项号。

> ### 2.2.4 最小项和最大项的关系

两者之间为互补关系：$m_i = M_i ，或者M_i = m_i$

> ## 2.3 逻辑函数的代数化简法

> ### 2.3.1 逻辑函数的最简形式

逻辑函数有不同形式，将其中包含的与项数最少，且每个与项中变量数最少的与-或表达式称为最简与-或表达式

> ### 2.3.2 代数化简法

运用逻辑代数的基本定律和恒等式进行化简的方法

> #### 2.3.2.1 并项

$$ A + \bar{A} = 1 $$
$$ L = \bar{A} \bar{B} C + \bar{A} \bar{B} \bar{C} = \bar{A} \bar{B} ( C + \bar{C} ) = \bar{A} \bar{B} $$

> #### 2.3.2.2 吸收

$$ A + AB = A $$
$$ L = \bar{A} B + \bar{A} BCD ( E + F ) = AB $$

> #### 2.3.2.3 消去

$$ A + \bar{A} B = A + B $$
$$ L = AB + \bar{A}C + \bar{B}C = AB + ( \bar{A} + \bar{B} ) C = AB + \overline{AB} C = AB + C $$

> #### 2.3.3 形式变化

通常在一片集成电路芯片中只有一种门电路，为了减少门电路的种类，需要对逻辑函数表达式进行变换。一般通过两次取反可变化。

> ## 2.4 逻辑函数的卡诺图化简法

> ### 2.4.1 用卡诺图表示逻辑函数

> #### 2.4.1.1 引出原理

- 逻辑函数可以表达为若干最小项相“或”的形式；
- 逻辑相邻的最小项：如果两个最小项只有一个变量互为反变量，那么，就称这两个最小项在逻辑上相邻;

> #### 2.4.1.2 形式

卡诺图：将n变量的全部最小项都填在小方格阵中，并使具有逻辑相邻的最小项在几何位置上也相邻地排列起来，这样,所得到的图形叫n变量的卡诺图。

![karnaugh](/images/Mathematical_Electronic/karnaugh.jpg)
> ## 2.5 硬件描述语言Verilog HDL基础
